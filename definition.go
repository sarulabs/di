package di

import (
	"errors"
	"reflect"
)

// NewDef creates a new *Def with only the Build function field set.
// You can also use the Def structure directly if it better fits your needs.
func NewDef(buildFunc func(ctn Container) (interface{}, error)) *Def {
	return &Def{
		Build: buildFunc,
	}
}

// NewDefFor creates a definition for an already built object.
// It is meant to replace the Set("object-name", objectInstance) of the basic Builder.
// If you want to add a name to the definition, you can use the setters.
// e.g.: NewDefFor(objectInstance).SetName("object-name")
func NewDefFor(obj interface{}) *Def {
	return NewDef(func(ctn Container) (interface{}, error) {
		return obj, nil
	})
}

// NewDefForType creates a definition that uses the result of NewBuildFuncForType(obj) as a Build function.
// The object generated by this definition will have the same type as the obj parameter.
// obj can only be a struct or a pointer to a struct. Other types are not supported.
// The fields of the generated object are filled with objects from the container depending on their types
// and the Is field of the definitions in the Container.
//
// The object will be generated using reflection. That implies that it is slower compared to a manually written function.
// But if you just use this for shared definitions in the main scope, it should not be a problem
// as the objects are only built once.
func NewDefForType(obj interface{}) *Def {
	buildFunc, err := NewBuildFuncForType(obj)
	if err != nil {
		return NewDef(func(ctn Container) (interface{}, error) {
			return nil, err
		})
	}
	return NewDef(buildFunc)
}

// Def contains information to build and close an object inside a Container.
type Def struct {
	// Build is the function that is used to create the object.
	Build func(ctn Container) (interface{}, error)
	// Close is the function that is used to clean the object when the container is deleted.
	// It can be nil if nothing needs to be done to close the object.
	Close func(obj interface{}) error
	// Name is the key that is used to retrieve the object from the container.
	Name string
	// Scope determines in which container the object is stored.
	// Typical scopes are "app" and "request".
	Scope string
	// Unshared is false by default. That means that the object is only created once in a given container.
	// They are singleton and the same instance will be returned each time "Get", "SafeGet" or "Fill" is called.
	// If you want to retrieve a new object every time, "Unshared" needs to be set to true.
	Unshared bool
	// Is allows to declare the type of the object generated by the Build function.
	// It is only declarative and no checks are done to ensure that this information is valid.
	// You can set multiple types, for example a structure and an interface implemented by the structure.
	// The Is field can be used to retrieve an object by its type instead of its name.
	// e.g.: ctn.Get(reflect.Type(MyStruct{}))
	// If multiple definitions have the same type, the one that was added last in the builder is used to retrieve the object.
	// The Is field is important if you are using NewBuildFuncForType.
	// It allows to create a Build function that creates an object whose fields are filled
	// depending on their type and the types of the definitions in the Container.
	Is []reflect.Type
	// Tags are not used inside this library. But they can be useful to sort your definitions.
	Tags []Tag

	// builderBound is set to true when the definition is bound to a Container by the builder.
	builderBound bool
	// builderIndex is the index used to store the definition in the containers.
	// It is used instead of the name for performance reasons.
	builderIndex int
}

// Index returns the index of the definition in its Container.
// If the definition is not bound to a Container, it returns -1.
func (d *Def) Index() int {
	if d.builderBound {
		return d.builderIndex
	}
	return -1
}

// SetBuild is the setter for the Build field.
func (d *Def) SetBuild(build func(ctn Container) (interface{}, error)) *Def {
	d.Build = build
	return d
}

// SetClose is the setter for the Close field.
func (d *Def) SetClose(close func(obj interface{}) error) *Def {
	d.Close = close
	return d
}

// SetName is the setter for the Name field.
func (d *Def) SetName(name string) *Def {
	d.Name = name
	return d
}

// SetScope is the setter for the Scope field.
func (d *Def) SetScope(scope string) *Def {
	d.Scope = scope
	return d
}

// SetUnshared is the setter for the Unshared field.
func (d *Def) SetUnshared(unshared bool) *Def {
	d.Unshared = unshared
	return d
}

// SetIs is the setter for the Is field.
// But the input parameters are not reflect.Type, but object instances.
// It uses NewIs to convert instances to []reflect.Type.
func (d *Def) SetIs(instances ...interface{}) *Def {
	d.Is = NewIs(instances...)
	return d
}

// SetTags is the setter for the Tag field.
func (d *Def) SetTags(tags ...Tag) *Def {
	d.Tags = tags
	return d
}

// NewIs applies reflect.TypeOf to all the given instances
// and returns a slice of []reflect.Type.
// It can be used to fill the Def.Is field.
// If an instance is already a reflect.Type, reflect.TypeOf will not be applied again.
// There is an issue with interfaces as this function can not get the type of a nil interface.
// NewIs((MyInterface)(nil)) will panic.
// So if you want to register an interface you need to use a reflect.Type as parameter:
// NewIs(reflect.TypeOf((*MyInterface)(nil)).Elem())
func NewIs(instances ...interface{}) []reflect.Type {
	is := []reflect.Type{}

	for _, instance := range instances {
		// Check if the instance is already a reflect.Type.
		switch t := instance.(type) {
		case reflect.Type:
			is = append(is, t)
			continue
		}
		// Try to get the type of the instance. It may not always be possible (nil interfaces).
		typeOf := reflect.TypeOf(instance)
		if typeOf == nil {
			panic("could not get the type of %#v (nil interfaces are not accepted in NewIs)")
		}
		is = append(is, typeOf)
	}

	return is
}

// Tag can contain more specific information about a Definition.
// It is useful to find a Definition thanks to its tags instead of its name.
type Tag struct {
	Name string
	Args map[string]string
	Data interface{}
}

// NewBuildFuncForType returns a Build function that creates an instance
// of an object having the same type as the given obj.
// Only structures and pointers to structures are supported as input parameter.
// It will try to set the fields of the generated struct with objects from the container.
// Only definitions with a Is field including the type of the field can be used.
// If there is no definition for the field type, the field is left empty.
// If there are more than one definition for the field type, the one that was inserted last in the builder is used.
func NewBuildFuncForType(obj interface{}) (func(ctn Container) (interface{}, error), error) {
	typ := reflect.TypeOf(obj)

	isPtr := false

	if typ.Kind() == reflect.Ptr && typ.Elem().Kind() == reflect.Struct {
		isPtr = true
		typ = typ.Elem()
	} else if typ.Kind() != reflect.Struct {
		return nil, errors.New("build functions can only be generated for struct and pointers to struct, but you provided a `" + typ.Kind().String() + "`")
	}

	return func(ctn Container) (interface{}, error) {
		objPtr := reflect.New(typ)
		obj := objPtr.Elem()

		for i := 0; i < typ.NumField(); i++ {
			fieldType := typ.Field(i).Type

			if !ctn.TypeIsDefined(fieldType) {
				continue
			}

			v := ctn.Get(fieldType)

			obj.Field(i).Set(reflect.ValueOf(v))
		}

		if isPtr {
			return objPtr.Interface(), nil
		}

		return obj.Interface(), nil
	}, nil
}

// DefMap is a collection of Def ordered by name.
type DefMap map[string]Def

// Copy returns a copy of the DefMap.
func (m DefMap) Copy() DefMap {
	defs := DefMap{}

	for name, def := range m {
		defs[name] = def
	}

	return defs
}
